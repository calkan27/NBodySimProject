from __future__ import annotations
import math
from typing import List
import numpy as np
import collections
from collections import deque
from .body import Body
from .body_view import BodyView
from .integrator import Integrator
from .softening_manager import SofteningManager
from .physics_utils import remove_center_of_mass_velocity
from .sim_config import SimConfig, _ALLOWED_MODES
from .hamiltonian_softening_integrator import HamiltonianSofteningIntegrator
from .diagnostics import Diagnostics 
import pandas as _pd
import copy
from .forces import _geometry, gravitational_force, dV_d_epsilon
from .console_throttle import ConsoleThrottle
from .simulation_state import SimulationState

class NBodySimulation:

	def __init__(
		self,
		config=None,
		bodies=None,
		masses=None,
		positions=None,
		velocities=None,
		G: float = 1.0,
		softening: float = 1e-3,
		min_softening: float = 0.0,
		adaptive: bool = False,
		adaptive_timestep: bool = None,
		adaptive_softening: bool = None,
		skip_init_corrector: bool = False,
		skip_cm_recenter: bool = False,
		integrator_mode: str | None = None,
	):
		if config:
			self.cfg = config.copy()
		else:
			self.cfg = SimConfig()
		self._state = SimulationState()

		if adaptive_timestep is not None:
			self._adaptive_timestep = bool(adaptive_timestep)
		elif adaptive is not None:
			self._adaptive_timestep = bool(adaptive)
		else:
			self._adaptive_timestep = bool(self.cfg.adaptive_timestep)

		if adaptive_softening is not None:
			self._adaptive_softening = bool(adaptive_softening)
		else:
			self._adaptive_softening = bool(self.cfg.adaptive_softening)
		if self._adaptive_softening and not self._adaptive_timestep:
			self._adaptive_timestep = True

		if not self._state.build_state(bodies, masses, positions, velocities):
			self._state.disable_simulation()
			return

		if self.cfg.fast_float32:
			self._state._pos = self._state._pos.astype(np.float32, copy=False)
			self._state._vel = self._state._vel.astype(np.float32, copy=False)
			self._state._acc = np.zeros_like(self._state._pos)

		if not skip_cm_recenter:
			self._state._vel = remove_center_of_mass_velocity(self._state._mass, self._state._vel)

		min_softening = max(0.0, min_softening)
		if softening < 0.0:
			softening = min_softening
		if min_softening == 0.0 and softening > 0.0:
			min_softening = 0.1 * softening

		self._min_softening = float(min_softening)
		self._softening_scale = self.cfg.softening_scale
		if integrator_mode is not None:
			self.cfg.integrator_mode = str(integrator_mode)
		self._integrator_mode = self.cfg.integrator_mode
		self.G = float(G)

		if self.G == 0.0 and self._integrator_mode != "ham_soft":
			self._integrator_mode = "verlet"

		if self._integrator_mode == "whfast":
			if self._adaptive_softening:
				print("[info] WHFast incompatible with adaptive softening; using Verlet")
				self._integrator_mode = "verlet"
			elif self.n_bodies > 0:
				dominance = np.max(self._state._mass) / np.sum(self._state._mass)
				if dominance < 0.2:
					self._integrator_mode = "verlet"

		self.manager = SofteningManager(self, softening, self._min_softening)
		self._max_softening: float = 10.0 * self.manager.s0

		self._epsilon = float(self.manager.s)
		self._pi = 0.0

		if self.manager.s > 0.0 and self._integrator_mode == "whfast":
			self._integrator_mode = "verlet"

		if not hasattr(self._state, "_acc"):
			self._state._acc = np.zeros_like(self._state._pos)
		self._state._buf_diff = None
		self._state._buf_r2 = None

		self._acc_cached = False
		self._in_integration = False
		self.softening_energy_delta = 0.0
		self._has_integrated = False

		if self._integrator_mode == "ham_soft":
			self._adaptive_softening = False

		if self._integrator_mode == "ham_soft":
			self._integrator = HamiltonianSofteningIntegrator(
				self,
				split_n_max=self.cfg.split_n_max,
				force_adaptive_timestep=self._adaptive_timestep,
			)
		else:
			self._integrator = Integrator(self, split_n_max=self.cfg.split_n_max)

		if (self._integrator_mode != "ham_soft") and (not self.cfg.use_energy_spring) and hasattr(self._integrator, "k_soft"):
			self._integrator.k_soft = 0.0

		self._acc_cached = False
		self._integrator._top_dt = getattr(self.cfg, "initial_dt", self.cfg.max_fraction_of_dt)

		if (
			not skip_init_corrector
			and self.G != 0.0
			and not self._adaptive_softening
			and not self._adaptive_timestep
			and self._integrator_mode != "ham_soft"
		):
			self._integrator.apply_corrector(self.cfg.corrector_order)

		if self.cfg.fast_float32:
			self._state._mass = self._state._mass.astype(np.float32, copy=False)

		self.set_fast_mode(float32=self.cfg.fast_float32, barrier=not self.cfg.disable_barrier)

	@property
	def integrator_mode(self) -> str:
		return str(self._integrator_mode)

	@property
	def n_bodies(self) -> int:
		return self._state.n_bodies

	@property
	def _mass(self) -> np.ndarray:
		return self._state._mass

	@_mass.setter
	def _mass(self, value: np.ndarray) -> None:
		self._state._mass = value

	@property
	def mass(self) -> np.ndarray:
		return self._state.mass

	@mass.setter
	def mass(self, value: np.ndarray) -> None:
		self._state.mass = value

	@property
	def _pos(self) -> np.ndarray:
		return self._state._pos

	@_pos.setter
	def _pos(self, value: np.ndarray) -> None:
		self._state._pos = value
		self._acc_cached = False

	@property
	def pos(self) -> np.ndarray:
		return self._state.pos

	@pos.setter
	def pos(self, value: np.ndarray) -> None:
		self._state.pos = value
		self._acc_cached = False

	@property
	def _vel(self) -> np.ndarray:
		return self._state._vel

	@_vel.setter
	def _vel(self, value: np.ndarray) -> None:
		self._state._vel = value
		self._acc_cached = False

	@property
	def vel(self) -> np.ndarray:
		return self._state.vel

	@vel.setter
	def vel(self, value: np.ndarray) -> None:
		self._state.vel = value
		self._acc_cached = False

	@property
	def _acc(self) -> np.ndarray:
		return self._state._acc

	@_acc.setter
	def _acc(self, value: np.ndarray) -> None:
		self._state._acc = value

	@property
	def acc(self) -> np.ndarray:
		return self._state.acc

	@property
	def soft(self) -> float:
		return self.manager.s

	@property  
	def max_softening(self) -> float:  
		return self._max_softening

	@property
	def softening(self) -> float:
		return self.manager.softening

	@property
	def s(self) -> float:
		return self.manager.s

	@property
	def adaptive_softening(self) -> bool:
		return self._adaptive_softening

	@adaptive_softening.setter
	def adaptive_softening(self, value: bool) -> None:
		new_val = bool(value)
		if new_val == self._adaptive_softening:
			return
		self._adaptive_softening = new_val
		self.manager.update_base_softening(new_val)
		self._acc_cached = False

	@property
	def _adaptive(self) -> bool:
		return self._adaptive_timestep

	@property
	def bodies(self) -> List[BodyView]:
		out = []
		for i in range(self.n_bodies):
			out.append(BodyView(self, i))
		return out

	def set_adaptive(self, value: bool) -> None:
		self._adaptive_timestep = bool(value)
		self._acc_cached = False
		return None

	def set_integrator_mode(self, mode: str) -> None:
		if self.G == 0.0:
			mode = "verlet"
		if mode not in _ALLOWED_MODES:
			return
		self._integrator_mode = mode

		if mode == "ham_soft":
			self._adaptive_softening = False

		if mode == "ham_soft":
			self._integrator = HamiltonianSofteningIntegrator(
				self,
				split_n_max=self.cfg.split_n_max,
				force_adaptive_timestep=self._adaptive_timestep,
			)
		else:
			self._integrator = Integrator(self, split_n_max=self.cfg.split_n_max)

		if not self.cfg.use_energy_spring and hasattr(self._integrator, "k_soft"):
			self._integrator.k_soft = 0.0

		self._acc_cached = False

	def set_use_yoshida(self, value: bool) -> None:
		print("set_use_yoshida is deprecated; use set_integrator_mode")
		if value:
			self._integrator_mode = "yoshida4"
		else:
			self._integrator_mode = "verlet"
		self._acc_cached = False
		return None

	@property
	def _use_yoshida(self):
		print("_use_yoshida is deprecated; use _integrator_mode")
		return self._integrator_mode in ("whfast", "yoshida4")

	def commit_state(self) -> None:
		if not hasattr(self, "_integrator"):
			return
		self._integrator.apply_corrector(self.cfg.corrector_order)

	def snapshot(self):
		return self._state.snapshot(self)

	@classmethod
	def restore(cls, state):
		cfg = state.get("cfg", state.get("sim", {}).get("cfg"))
		if cfg:
			cfg = cfg.copy()
		else:
			cfg = SimConfig()

		sim_data  = state.get("sim", state)
		soft_data = state.get("softening_mgr_state", state.get("softening_mgr", {}))
		sim_state = state.get("sim_state", sim_data.get("flags", {}))

		sim = cls(
			config=cfg,
			masses=sim_data["masses"],
			positions=sim_data["positions"],
			velocities=sim_data["velocities"],
			softening=state.get("softening", soft_data.get("s", 1e-3)),
			min_softening=0.0,
			adaptive=sim_state.get("_adaptive_timestep", False),
			adaptive_softening=sim_state.get("_adaptive_softening", False),
			skip_init_corrector=True,
			skip_cm_recenter=True,
		)

		SimulationState.restore_to_sim(state, sim)
		return sim

	def to_jacobi(self):
		m = self._state._mass
		pos = self._state._pos
		vel = self._state._vel
		n = len(m)
		jac_pos = np.empty_like(pos)
		jac_vel = np.empty_like(vel)
		R = m[0] * pos[0]
		V = m[0] * vel[0]
		M_prev = m[0]
		jac_pos[0] = pos[0]
		jac_vel[0] = vel[0]
		for i in range(1, n):
			cm_pos = R / M_prev
			cm_vel = V / M_prev
			jac_pos[i] = pos[i] - cm_pos
			jac_vel[i] = vel[i] - cm_vel
			R += m[i] * pos[i]
			V += m[i] * vel[i]
			M_prev += m[i]
		return jac_pos, jac_vel

	def from_jacobi(self, jac_pos, jac_vel):
		m = self._state._mass
		n = len(m)

		pos = np.empty_like(jac_pos)
		vel = np.empty_like(jac_vel)

		pos[0] = jac_pos[0]
		vel[0] = jac_vel[0]

		R = m[0] * pos[0]      
		V = m[0] * vel[0]     
		M_prev = m[0]          

		for i in range(1, n):
			cm_pos = R / M_prev
			cm_vel = V / M_prev

			pos[i] = jac_pos[i] + cm_pos
			vel[i] = jac_vel[i] + cm_vel

			R += m[i] * pos[i]
			V += m[i] * vel[i]
			M_prev += m[i]

		return pos, vel

	def accelerations(self) -> np.ndarray:
		return self._accel()

	def _accel(self, *, pos=None, s2=None) -> np.ndarray:
		if self.n_bodies < 2 or self.G == 0.0:
			self._state._acc.fill(0.0)
			self._acc_cached = True
			if self._integrator_mode == "ham_soft":
				self._last_force_eps = float(getattr(self, "_epsilon", self.manager.s))
			else:
				self._last_force_eps = float(math.sqrt(max(float(self.manager.step_s2), 0.0)))
			return self._state._acc

		if self._integrator_mode == "ham_soft":
			eps = float(getattr(self, "_epsilon", self.manager.s))
			F = gravitational_force(self._state._pos, self._state._mass, eps=eps, G=self.G)
			accel = F / self._state._mass[:, None]
			self._state._acc[:] = accel
			self._acc_cached = True
			self._last_force_eps = float(eps)
			return self._state._acc

		if pos is None:
			pos_use = self._state._pos
		else:
			pos_use = pos

		if s2 is None:
			s2_use = float(self.manager.step_s2)
		else:
			s2_use = float(s2)
			if not (s2_use == s2_use and s2_use != float("inf") and s2_use != float("-inf")):
				s2_use = float(self.manager.step_s2)

		if s2_use > 0.0:
			eps_eff = float(math.sqrt(s2_use))
		else:
			eps_eff = 0.0

		F = gravitational_force(pos_use, self._state._mass, eps=eps_eff, G=self.G)
		accel = F / self._state._mass[:, None]

		self._state._acc[:] = accel
		self._acc_cached = True
		self._last_force_eps = float(eps_eff)
		return self._state._acc

	def _freeze_softening_for_hamsoft(self) -> None:
		if self._integrator_mode != "ham_soft":
			return

		if getattr(self, "_hamsoft_freeze_active", False):
			return

		eps_now = float(getattr(self, "_epsilon", self.manager.s))

		self.manager.s = float(eps_now)
		self.manager.s2 = float(eps_now * eps_now)
		self.manager._step_s2 = float(eps_now * eps_now)

		if hasattr(self.manager, "update_continuous"):
			self.manager._update_continuous_saved = self.manager.update_continuous

			def _locked_update_continuous(eps_new: float) -> None:
				self.manager.s = float(eps_now)
				self.manager._step_s2 = float(eps_now * eps_now)
				return

			self.manager.update_continuous = _locked_update_continuous

		self._hamsoft_freeze_active = True
		self._frozen_force_eps = float(eps_now)
		return


	def _unfreeze_softening_for_hamsoft(self) -> None:

		if self._integrator_mode != "ham_soft":
			return

		if not getattr(self, "_hamsoft_freeze_active", False):
			return

		saved = getattr(self.manager, "_update_continuous_saved", None)
		if saved is not None:
			self.manager.update_continuous = saved
			delattr(self.manager, "_update_continuous_saved")

		eps_now = float(getattr(self, "_epsilon", self.manager.s))
		self.manager.s = float(eps_now)
		self.manager.s2 = float(eps_now * eps_now)
		self.manager._step_s2 = float(eps_now * eps_now)

		self._hamsoft_freeze_active = False
		return


	def _disable_simulation(self):
		self._state.disable_simulation()
		self.softening_energy_delta = 0.0

	def set_fast_mode(self, *, float32: bool = True, barrier: bool = True):
		self.cfg.fast_float32   = bool(float32)
		self.cfg.disable_barrier = not barrier
		self._state.set_fast_mode(float32)
		self._acc_cached = False

	def copy(self, *, deep: bool = True) -> "NBodySimulation":
		if not deep:
			return self

		self.commit_state()
		return NBodySimulation.restore(self.snapshot())

	def __copy__(self):
		return self.copy(deep=True)

	def __deepcopy__(self, memo=None):
		return self.copy(deep=True)

	def _compute_accelerations(self, *, pos=None, s2=None) -> np.ndarray:
		return self._accel(pos=pos, s2=s2)

	def _get_min_separation(self) -> float:
		if self.n_bodies < 2:
			return float('inf')
		d = self._state._pos[:, None, :] - self._state._pos[None, :, :]
		d2 = (d ** 2).sum(axis=-1)
		np.fill_diagonal(d2, np.inf)
		return max(float(d2.min()) ** 0.5, 1e-12)

	def step(self, dt: float) -> None:
		if dt == 0.0 or self.n_bodies == 0:
			return
		dt = float(dt)

		self._integrator.step(dt)

		self._has_integrated = True
		self._acc_cached     = False
		self._last_dt        = dt          

	def get_current_softening_squared(self) -> float:
		return self.manager.step_s2

	def get_integrator_name(self) -> str:
		return self._integrator_mode

	def _build_state(self, bodies, masses, positions, velocities) -> bool:
		return self._state.build_state(bodies, masses, positions, velocities)

	def debug_adaptive_softening(self) -> dict:
		if hasattr(self, 'manager'):
			current_s2 = float(self.manager.step_s2)
		else:
			current_s2 = float('nan')
		min_separation = float(self._get_min_separation())
		adaptive = bool(self._adaptive_softening)
		return {
			'current_s2': current_s2,
			'min_separation': min_separation,
			'adaptive': adaptive
		}

