from __future__ import annotations
from dataclasses import dataclass
from typing import Final
import copy
import numpy as np
from .hamsoft_constants import LAMBDA_SOFTENING as _LAM_SOFT
from .barrier import barrier_force
from .softening import grad_eps_target as _grad_ss, eps_target as _eps_target_ss
import math
from math import sqrt, sin, cos


__all__ = [
    "PhaseState",
    "spring_oscillation",
    "strang_softening_step",
]

@dataclass(frozen=True, slots=True)
class PhaseState:
    q: np.ndarray         
    p: np.ndarray         
    epsilon: float        
    pi: float             
    m: np.ndarray        





def spring_oscillation(
    state: PhaseState,
    dt: float,
    k_soft: float,
    *,
    mu: float | None = None,
    cfg=None,
    q_frozen: np.ndarray | None = None,
    integrator=None,
) -> PhaseState:
    """
    Exact harmonic update for (ε, π) around ε*(q), including the momentum impulse on p.

    Closed-form (as seen in the UTASND paper’s equation for the S‑subflow closed form, insert exact eq. number):
      ω = sqrt(k_soft/μ_ε),  δ = ε - ε*(q),  \bar{η} = π / (μ_ε ω),  θ = ω Δt
      δ'      =  cosθ δ + sinθ \bar{η}
      \bar{η}' = -sinθ δ + cosθ \bar{η}
      ε' = ε*(q) + δ'
      π' = μ_ε ω \bar{η}'
      p' = p + [ k_soft (δ sinθ + \bar{η} (1 - cosθ)) / ω ] ∇ε*(q)

    Notes:
      • If the integrator provides _eps_target but not _grad_eps_target, we KEEP ε*(q) from the integrator
        and set ∇ε*(q) = 0, without recomputing ε*(q) via helpers.
      • Helper-based fallback is used ONLY if ε*(q) itself is missing or non‑finite.
      • Small-angle branches for sin/cos are preserved; no context managers or exceptions.
    """
    import math
    # --- Unpack state (arrays copied at return) ---
    q   = np.asarray(state.q, dtype=float)
    p   = np.asarray(state.p, dtype=float)
    m   = np.asarray(state.m, dtype=float)
    eps = float(state.epsilon)
    pi  = float(state.pi)

    # --- Determine μ_ε ---
    mu_eff = None
    if isinstance(mu, (int, float, np.floating)):
        mu_val = float(mu)
        if np.isfinite(mu_val) and mu_val > 0.0:
            mu_eff = mu_val
    if mu_eff is None and integrator is not None and hasattr(integrator, "mu_soft"):
        mu_val = float(getattr(integrator, "mu_soft"))
        if np.isfinite(mu_val) and mu_val > 0.0:
            mu_eff = mu_val
    if mu_eff is None:
        s = float(np.sum(m)) if np.all(np.isfinite(m)) else 0.0
        mu_eff = s if s > 0.0 and np.isfinite(s) else 1.0

    # --- Reference q for ε*(q) evaluation ---
    q_ref = np.asarray(q_frozen, dtype=float) if q_frozen is not None else q

    # --- Acquire ε*(q) and ∇ε*(q) ---
    eps_star = None
    grad = None
    eps_min = 0.0
    eps_max = 0.0

    if integrator is not None:
        f_star = getattr(integrator, "_eps_target", None)
        f_grad = getattr(integrator, "_grad_eps_target", None)

        if callable(f_star):
            val = f_star(q=q_ref) if "q" in f_star.__code__.co_varnames else f_star(q_ref)
            if isinstance(val, (int, float, np.floating)):
                eps_star = float(val)

        if callable(f_grad):
            g = f_grad(q_ref)
            if isinstance(g, np.ndarray):
                grad = g

        sim = getattr(integrator, "sim", None)
        if sim is not None:
            vmin = getattr(sim, "_min_softening", None)
            vmax = getattr(sim, "_max_softening", None)
            if isinstance(vmin, (int, float, np.floating)):
                eps_min = float(vmin)
            if isinstance(vmax, (int, float, np.floating)):
                eps_max = float(vmax)



# If the integrator gives ε*(q) but not ∇ε*(q), compute ∇ε* via helpers (keeps ε* from the integrator).
	eps_star_is_finite = isinstance(eps_star, (int, float, np.floating)) and np.isfinite(float(eps_star))
	grad_is_valid = isinstance(grad, np.ndarray) and grad.shape == q_ref.shape and np.all(np.isfinite(grad)) if grad is not None else False

	if eps_star_is_finite and not grad_is_valid:
		# use cfg if available to keep α, λ consistent with the rest of the code/tests
		alpha = float(getattr(cfg, "alpha", 0.1) or 0.1)
		lam   = float(getattr(cfg, "lambda_softening", 1.0) or 1.0)
		try:
			grad = _grad_ss(q_ref, alpha=alpha, lam=lam)
		except Exception:
			# absolute last-resort safety — but this shouldn't trigger in your tests
			grad = np.zeros_like(q_ref, dtype=float)


    # --- Helper-based fallback ONLY if ε*(q) is missing or non‑finite ---
    if not eps_star_is_finite:
        alpha = None
        lam = None
        if cfg is not None:
            a_raw = getattr(cfg, "alpha", None)
            if isinstance(a_raw, (int, float, np.floating)) and np.isfinite(float(a_raw)) and float(a_raw) > 0.0:
                alpha = float(a_raw)
            l_raw = getattr(cfg, "lambda_softening", None)
            if isinstance(l_raw, (int, float, np.floating)) and np.isfinite(float(l_raw)) and float(l_raw) > 0.0:
                lam = float(l_raw)
        if alpha is None:
            alpha = 0.1
        if lam is None:
            lam = 1.0

        use_helpers = ("_eps_target_ss" in globals()) and ("_grad_ss" in globals())
        if use_helpers:
            eps_star = float(_eps_target_ss(q_ref, alpha=alpha, lam=lam))
            grad = _grad_ss(q_ref, alpha=alpha, lam=lam)
        else:
            eps_star = eps
            grad = np.zeros_like(q_ref, dtype=float)

        if not (isinstance(eps_min, (int, float, np.floating)) and np.isfinite(eps_min)):
            eps_min = 0.0
        if not (isinstance(eps_max, (int, float, np.floating)) and eps_max > eps_min):
            eps_max = eps_min + 10.0

    # --- Clip ε* into (ε_min, ε_max) with a tiny interior margin ---
    span = eps_max - eps_min
    if not np.isfinite(span) or span <= 0.0:
        span = 1.0
    delta_clip = 1.0e-6 * span
    lower = eps_min + delta_clip
    upper = eps_max - delta_clip
    eps_star_clipped = float(eps_star) if isinstance(eps_star, (int, float, np.floating)) else 0.5 * (lower + upper)
    if not np.isfinite(eps_star_clipped):
        eps_star_clipped = 0.5 * (lower + upper)
    if eps_star_clipped < lower:
        eps_star_clipped = lower
    elif eps_star_clipped > upper:
        eps_star_clipped = upper

    eps_star_used = float(eps_star_clipped)
    grad = np.asarray(grad, dtype=float)

    # --- If k_soft <= 0, free drift ε by its velocity; no momentum impulse ---
    if not (isinstance(k_soft, (int, float, np.floating)) and np.isfinite(float(k_soft))):
        k_soft = 0.0

    if k_soft <= 0.0:
        eps_new = eps + (pi / mu_eff) * float(dt) if (mu_eff != 0.0 and np.isfinite(mu_eff)) else eps
        pi_new = pi
        impulse_coeff = 0.0
    else:
        # Harmonic oscillator about ε*(q): exact closed form
        omega_sq = k_soft / mu_eff if mu_eff != 0.0 else 0.0
        if omega_sq <= 0.0 or not np.isfinite(omega_sq):
            omega = 0.0
        else:
            omega = math.sqrt(omega_sq)

        theta = omega * float(dt)

        # Small-angle series if |θ| < 1e-8
        if abs(theta) < 1.0e-8:
            th2 = theta * theta
            th4 = th2 * th2
            s = theta * (1.0 - th2/6.0 + th4/120.0)
            one_minus_c = th2*(0.5 - th2/24.0 + th4/720.0)
            c = 1.0 - one_minus_c
        else:
            s = math.sin(theta)
            c = math.cos(theta)
            one_minus_c = 1.0 - c

        delta   = eps - eps_star_used
        etabar  = pi / (mu_eff * omega) if (omega != 0.0 and mu_eff != 0.0) else 0.0

        delta_p  =  c * delta + s * etabar
        etabar_p = -s * delta + c * etabar

        eps_new = eps_star_used + delta_p
        pi_new  = mu_eff * omega * etabar_p

        # Momentum impulse along ∇ε*(q)
        if omega != 0.0:
            impulse_coeff = k_soft * (delta * s + etabar * one_minus_c) / omega
        else:
            impulse_coeff = 0.0

    p_new = p + impulse_coeff * grad
    return PhaseState(q=q.copy(), p=p_new, epsilon=float(eps_new), pi=float(pi_new), m=m.copy())

def strang_softening_step(
    state: PhaseState,
    dt: float,
    *,
    k_soft: float,
    eps_min: float,
    eps_max: float,
    k_wall: float = 1.0e9,
    n_exp: int | None = None,
) -> PhaseState:

    return spring_oscillation(state, dt, k_soft)

